<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>OOP on 拾忆</title>
    <link>http://huanghg.github.io/series/oop/</link>
    <description>Recent content in OOP on 拾忆</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Mon, 30 Dec 2019 17:38:37 +0800</lastBuildDate>
    
	<atom:link href="http://huanghg.github.io/series/oop/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>漫谈面向对象（OOP）</title>
      <link>http://huanghg.github.io/posts/20191230oop/</link>
      <pubDate>Mon, 30 Dec 2019 17:38:37 +0800</pubDate>
      
      <guid>http://huanghg.github.io/posts/20191230oop/</guid>
      <description>简介 ​	相传盘古开天辟地，举手顶天，双脚踏地，撑开混沌天地。最后体力不支，身躯化为山脉，血液演变成河流。混沌世界由此开启。在现实世界里，万物皆对象，万物拥有属性，可执行动作
​	二十世纪末，二十一世纪初，出现了一种新物种——程序猿，一种特殊的物种，通过0和1构建了一个虚拟的世界。将世间万物抽象成各种各样的对象，对象包含属性和方法
​	单一文化会让人类发展历程停滞不前。人类历史齿轮之所以可以快速往前行驶，靠的是文化间相互碰撞。中国古代有百家争鸣，外国有文艺复兴
​	程序世界亦然。面向对象（OOP）有三个特性，继承，封装，多态。这三大特性稳稳地支撑面向对象，让面向对象一度成为程序猿编程首选范式。所谓路遥知马力，用久了，面向对象的诟病也相继出现了
继承 继承，定义子类继承于父类，共性放在父类，子类负责差异化。这带来了一定的便利，可以起到很好的复用效果，相同的代码只需要在父类写一份，所有的子类可以添加新的方法，也可以重写父类的方法，以达到子类间相不影响
**风险：**但是父类和子类的相互影响是也是bug潜伏的有利条件
解决方案：减少继承的层级，通过组合来代替继承
封装 封装，无论是通过声明属性方法的作用域，还是通过头文件的方式屏蔽内部实现。其实都是利用了封装的特性，把外在不关心的，不想让外部修改的，封装在类的内部，只对外部暴露部分属性，以及部分接口供配置或者修改。符合设计模式里面的最少知道原则
**风险：**但是对外暴露属性，无疑是增大了属性的作用域，也就是可以修改的地方多了，就不纯粹了，因为属性被修改导致的bug的风险就高了
解决方案：尽量少对外暴露属性，可以通过方法的方式供外部配置或者修改属性
**风险：**另外对外暴露方法，如果不是值传递，而是指针传递。外部也持有这个对象指针，也就是外部也可以修改这个对象
解决方案：是方法内部对对象指针进行深拷贝
多态 多态不是面向对象的独有特性。多态可以分为编译时多态和运行时多态。编译时多态大多体现在接口上的多态，比如同样是构造方法，但是可以通过不一样的参数列表，来达到实例化不同对象的效果。运行时多态建立在继承特性上，对外接口接收的是父类，同一个方法，当传进去的具体实体类不一样，会产生不一样的结果，而这个具体实体类，需要在运行时才知道是什么类型
面向对象中，很多问题终究在于属性的作用域太广，作用域广，被修改的地方就广，bug很多时候就这么出现了
这时候函数式编程就凸显了优势。函数式编程主张减少对外部的引用，函数是一等公民，跟基础类型的一样，可以当作参数一样传递，也可以返回一个函数
参考 知海匠库：面向对象编程不如函数式编程？
函数式编程初探</description>
    </item>
    
  </channel>
</rss>